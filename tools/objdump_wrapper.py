#!/usr/bin/env python3

import argparse
from dataclasses import dataclass, field
from typing import Optional
import subprocess
from pathlib import Path
import logging
import re
import hashlib

logging.basicConfig(level=logging.INFO)

# NOQA - mostly generated by LLM.

# Function for running shell commands
def run_shell(cmd: str) -> tuple[str, str]:
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, universal_newlines=True)
    stdout, stderr = process.communicate()
    if (ecode := process.returncode):
        raise ValueError(f"Command <{cmd}> exited with {ecode}")
    return stdout, stderr

@dataclass
class ObjdumpInsnParsed:
    insn_name: str
    insn_value: int
    insn_size_bytes: int
    
    full_line: str
    file_offset: int

@dataclass
class ObjdumpFunctionParsed:
    fn_name: str
    start_fileoff_incl: int
    insns: list[ObjdumpInsnParsed] = field(default_factory=list)

    @property
    def end_fileoff_excl(self) -> int:
        assert len(self.insns)
        last_insn = self.insns[-1]
        return last_insn.file_offset + last_insn.insn_size_bytes

    def contains_fileoff(self, fileoff: int) -> bool:
        return (self.start_fileoff_incl <= fileoff < self.end_fileoff_excl)

    def pformat_signature(self) -> str:
        return f"{self.fn_name} (start_fileoff={hex(self.start_fileoff_incl)}, end_fileoff={hex(self.end_fileoff_excl)})"

    def coherency_check(self):
        if not len(self.insns):
            raise ValueError("Function has empty instructions list!")

        # instructions are ordered and non-overlapping.
        for a, b in zip(self.insns, self.insns[1:]):
            max_insn_size = 15 # 15 is for x86_64, i hope no other arch has longer instructions :)
            if a.insn_size_bytes not in range(1, max_insn_size + 1):
                raise ValueError(f"function {self.fn_name}: Instruction size should be at least 1 byte and at most {max_insn_size} bytes, not {a.insn_size_bytes} (file offset: {a.file_offset}, full line: {a.full_line})")
            if b.file_offset <= a.file_offset:
                raise ValueError(f"function {self.fn_name}: Instructions file offset is not strictly ordered: {a}, {b}")

        # function boundary coherence.
        self_start_fileoff = self.start_fileoff_incl
        if (first_insn_fileoff := self.insns[0].file_offset) != self_start_fileoff:
            raise ValueError(f"function {self.fn_name}: start file offset ({hex(self_start_fileoff)}) does not match it's first instruction's ({hex(first_insn_fileoff)})")
    
    def __repr__(self):
        return self.pformat_signature()

@dataclass
class ObjdumpOutputParsed:
    functions : list[ObjdumpFunctionParsed] = field(default_factory=list)

    def coherency_check(self):
        fs = self.functions
        assert len(fs)

        duplicates =  set([f for f in fs if fs.count(f) > 1])

        if duplicates:
            raise RuntimeError(f"Function names should be unique! {duplicates} are not.")

        for f1, f2 in zip(self.functions, self.functions[1:]):
            if (s1 :=f1.start_fileoff_incl) >= (s2 := f2.start_fileoff_incl):
                raise RuntimeError(f"Function {f1.fn_name} (start={hex(s1)}) is defined before function {f2.fn_name} (start={hex(s2)})")
        
        for f in self.functions:
            f.coherency_check()

def parse_objdump_output(objdump_output: str) -> ObjdumpOutputParsed:
    sections, current_section = {}, None
    functions : list[ObjdumpFunctionParsed] = []

    for line in objdump_output.splitlines():
        if not line.strip() or "file format " in line:
            continue

        tokens = line.split()

        # Case 1: Section Header
        # Expected format: "Disassembly of section .text:"
        if line.startswith("Disassembly of section "):
            # Extract the section name (e.g., ".text")
            current_section = line.split()[-1][:-1]  # Remove the trailing colon
            sections[current_section] = []
            continue

        # Case 2: Function Header (not relevant for section processing)
        # Expected format: "0000000000001050 <function_name> (File Offset: 0x1050):"
        if len(tokens) == 5 and (fn_name_token := tokens[1]).startswith("<") and fn_name_token.endswith(">") and (fileoff_token := tokens[-1]).endswith("):"):
            vma = int(tokens[0], 16)
            file_offset = int(fileoff_token[:-2], 16)
            vma_minus_fileoff = vma - file_offset

            functions.append(cur_fn := ObjdumpFunctionParsed(
                fn_name=fn_name_token[1:-1],
                start_fileoff_incl=file_offset,
            ))

            del vma, file_offset
            continue

        # Case 3: Instruction Line
        # Expected format: "  402000: byte1 byte2 push/mov/... tail1 tail2", with undefined amount of byteX and tailX words.
        if len(tokens) >= 2 and tokens[0].endswith(":"):
            # NOTE: regex is hard to avoid here, as number of words before "insn_name" is not known. i'm not aware of any objdump's CLI switch that could help
            pattern = r"\s*(?P<insn_vma>[0-9a-f]+):(?P<insn_bytes>(\s+[0-9a-f][0-9a-f])+)\s*(?P<insn_name>\S*).*"
            res = re.fullmatch(pattern, line)
            if res is None:
                raise RuntimeError(f"internal error: regex mismatch on line '{line}'")

            insn_vma = int(res.group("insn_vma"), 16)
            insn_name = res.group("insn_name").strip()

            # insn_bytes[0] is the most significant byte.
            insn_bytes : list[str] = list(res.group("insn_bytes").split().__reversed__())

            insn_size = len(insn_bytes)

            insn_value = int("".join(insn_bytes), 16)

            insn_file_offset = insn_vma - vma_minus_fileoff

            insn = ObjdumpInsnParsed(
                insn_name=insn_name,
                insn_size_bytes=insn_size,
                insn_value=insn_value,

                full_line=line.strip(),
                file_offset=insn_file_offset,
            )

            sections[current_section].append(insn)
            cur_fn.insns.append(insn)

    # TODO: legacy, maybe will be used in future.
    del sections

    res = ObjdumpOutputParsed(functions=functions)
    res.coherency_check()
    return res

def count_instructions(objdump_parsed: ObjdumpOutputParsed, range_start: int, range_end: int) -> dict[str, int]:
    from collections import defaultdict
    res = defaultdict(int)

    for f in objdump_parsed.functions:
        for insn in f.insns:
            if range_start <= insn.file_offset < range_end:
                res[insn.insn_name] += 1
    
    return dict(res)

def get_build_id_if_present(elf: Path) -> Optional[str]:
    assert elf.exists()
    stdout, _ = run_shell(f"file {elf}")
    words = stdout.split()
    starswith_magic = "BuildID[sha1]="
    matches = [x for x in words if x.startswith(starswith_magic)]
    if len(matches) != 1:
        raise ValueError(f"Was expecting a single match for word starting with {starswith_magic}, got {len(matches)} instead")
    # strip everything before '=' and a trailing comma
    res = matches[0].split("=")[-1][:-1]
    return res

def disas(func: ObjdumpFunctionParsed) -> str:
    lines = []

    # function header
    lines.append(func.pformat_signature())

    for insn in func.insns:
        lines.append(insn.full_line)

    return "\n".join(lines) 

def addr2line(objdump_output: ObjdumpOutputParsed, file_offset: int) -> ObjdumpFunctionParsed:
    matches = [f for f in objdump_output.functions if f.contains_fileoff(file_offset)]
    if len(matches) != 1:
        raise RuntimeError(f"Was expecting exactly one match, got {len(matches)} instead!")
    return matches[0]

def system_invoke_objdump_or_use_cached(objdump_executable: Path, elf_file: Path, cache_dir: Path = Path(__file__).parent) -> str:

    if build_id := get_build_id_if_present(elf_file):
        cache_fname = f"objdump_buildid_{build_id}"
    else:
        hash = hashlib.md5(elf_file.read_bytes()).hexdigest()
        cache_fname = f"objdump_md5_{hash}"

    cache_file = cache_dir / cache_fname

    if not cache_file.exists():
        logging.info(f"cache not yet there (missing {cache_file})")
        cmd = f"{objdump_executable}  -M no-aliases  --disassemble-zeroes --wide -Fd {elf_file}"
        stdout, _ = run_shell(cmd)
        cache_file.write_text(stdout)
    else:
        logging.info(f"cache will be reused ({cache_file})")
        stdout = cache_file.read_text()

    return stdout

# Main function to parse arguments and run the script
def main():
    hex_or_min = lambda _val: 0 if _val == "-" else int(_val, 16)
    hex_or_max = lambda _val: 0xffffffff_ffffffff if _val == "-" else int(_val, 16)
    
    parser = argparse.ArgumentParser(description="Parse ELF file and summarize CPU instructions.")
    parser.add_argument("-d", "--objdump-executable", type=Path, help="path to 'objdump' executable, useful if using one from cross-toolchain (e.g. RISC-V)", default="objdump")
    parser.add_argument("-e", "--elf_file", type=Path, help="Path to the ELF file.", required=True)
    
    subparsers = parser.add_subparsers(dest="mode", required=True)

    all_parsers = [
        nm_parser := subparsers.add_parser("nm", help="print all the function names, like 'nm' does"),

        count_parser := subparsers.add_parser("count", help="count instructions (grouped by type) in specidfied file offset range"),
        disas_parser := subparsers.add_parser("disas", help="disassemble instructions in specidfied file offset range"),

        find_parser := subparsers.add_parser("find", help="for a given file offset, determine what function it belongs to (like 'addr2line')."),
    ]

    find_parser.add_argument("offset", type=lambda x: int(x, 16))

    for x in (count_parser, disas_parser):
        func_or_range_parser = x.add_subparsers(dest="func_or_range", required=True)
        range_parser = func_or_range_parser.add_parser("range")
        range_parser.add_argument("range_start", type=hex_or_min, help="Start of the file offset range (inclusive, in hex) or '-' if RANGE_MIN should be used.")
        range_parser.add_argument("range_end", type=hex_or_max, help="End of the file offset range (exclusive, in hex)  or '-' if RANGE_MAX should be used.")
        func_name_parser = func_or_range_parser.add_parser("func")
        func_name_parser.add_argument("func_name")
    
    args = parser.parse_args()

    # collect objdump
    objdump_raw_output = system_invoke_objdump_or_use_cached(objdump_executable=args.objdump_executable, elf_file=args.elf_file)
    # parse objdump
    parsed_output = parse_objdump_output(objdump_raw_output)

    if args.mode in ["disas", "count"]:
        if (func_or_range := args.func_or_range) == "range":
            # TODO: not used at all in 'count' mode.
            start, end = args.range_start, args.range_end
            filtered = [f for f in parsed_output.functions if f.start_fileoff_incl <= end]
            filtered = [f for f in filtered if f.end_fileoff_excl > start]
            functions_of_interest = [filtered]
            del filtered, start, end
        elif func_or_range == "func":
            func_name = args.func_name
            matches = [f for f in parsed_output.functions if f.fn_name == func_name]
            if len(matches) != 1:
                raise RuntimeError(f"Could not find function <{func_name}>")
            functions_of_interest = [matches[0]]

    if (mode := args.mode) == "nm":
        for f in parsed_output.functions:
            print(f.pformat_signature())
    elif mode == "count":

        # XXX technical debt.
        if (func_or_range := args.func_or_range) == "range":
            start, end = args.range_start, args.range_end
        else:
            start, end = functions_of_interest[0].start_fileoff_incl, functions_of_interest[0].end_fileoff_excl

        res = count_instructions(parsed_output, start, end)
        print(f"range: [{hex(start)}, {hex(end)}) // {hex(end - start)}={end - start} bytes")
        print(f"num_instructions: {sum(res.values())}")
        print("instructions summary:")
        for insn_name, count in sorted(res.items(), key=lambda x: x[1], reverse=True):
            print(f"{insn_name.ljust(10)} {count}")
    elif mode == "disas":
        res : str = "\n".join(disas(x) for x in functions_of_interest)
        print(res)
    elif mode == "find":
        f = addr2line(objdump_output=parsed_output, file_offset=args.offset)
        print(f.pformat_signature())


if __name__ == "__main__":
    main()

